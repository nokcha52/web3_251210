<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>카운트업</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: rgb(80, 35, 35);
            color: #fff;
            height: 3000px;

        }
        .counter_section{
            margin-top: 1000px;
            display: flex;
            gap: 100px;
            justify-content: center;
        }
        .counter_box {
            text-align: center;
        }
        .nubmer {
            font-size: 68px;
            color: rgb(168, 110, 110);
        }
        .label {
            font-size: 20px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <section class="counter_section">
        <div class="counter_box">
            <div class="number" data-target="1500">0</div>
            <div class="label">아바타</div>
        </div>
        <div class="counter_box">
            <div class="number" data-target="950">0</div>
            <div class="label">주토피아</div>
        </div>
        <div class="counter_box">
            <div class="number" data-target="99">0</div>
            <div class="label">짱구극장판</div>
        </div>
    </section>
    <script>
        const numbers = document.querySelectorAll('.number');
        console.log(numbers);

        function animateCounter(counter){
            counter.innerText = "0";
            const target =+ counter.getAttribute("data-target");

            let current = 0;
            const update = ()=>{
                const increment = target/100
                // 증가하는 속도를 똑같이 만들기 위해서

                if(current < target){
                    current += increment;
                    counter.innerText = Math.ceil(current);
                }else {
                    counter.innerText = target.toLocaleString();
                    //current가 목표에 도달했다면 최종적으로 target을 표시함
                    //toLocaleString: 1000단위가 넘어갈때 ,를 붙여줌
                }
            };

            update();
        }

        const observer = new IntersectionObserver(entris=>{
            entris.forEach(entry => {
                if(entry.isIntersecting)
                //isIntersecting : 변화가 생긴 entry가 화면에 들어왔니? / true false
                //entry가 화면에 보이고 있다면 true, 아니면 false
                animateCounter(entry.target);
                // target : 감시중인 요소의 dom을 가져옴
            });
        });
        //IntersectionObserver: 뷰포트를 기준으로 대상 요소가 나타날 때 콜백함수를 호출하는 API
        //우리가 원하는 요소가 화면에 들어왔는지 감시하는 도구(감시대상이 화면 안에 들어오거나 밖으로 나가거나 할 때 자동으로 실행됨)
        //entris : 감시중인 요소에 변화가 생기면 변화가 생긴 요소를 entris에 넣음 entris는 요소들을 배열형식으로 보관하는 장소
        // 요소들을 감시하다가 무슨 일이 생기면 엔트리스에 이벤트가 일어난 요소들이 들어가게 됨

        numbers.forEach(num => {
            observer.observe(num);
        });
    </script>
</body>
</html>